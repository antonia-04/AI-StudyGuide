#### Ce este Problema Comisului Voiajor?

Este o problemă clasică de **optimizare combinatorică**:

> Un comis voiajor trebuie să viziteze fiecare dintre cele $n$ orașe **exact o singură dată** și să se întoarcă în orașul de plecare, astfel încât **distanța totală parcursă** să fie **minimă**.


#### Reprezentarea datelor

- Orașele sunt reprezentate printr-o listă de poziții $(x_i, y_i)$ în planul 2D.
- Distanța dintre două orașe $i$ și $j$ este de obicei distanța euclidiană:

$d(i, j) = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$



#### Cum aplicăm algoritmi evolutivi?

Vom rezolva TSP cu un **algoritm genetic**, o categorie de algoritmi evolutivi.


#### Reprezentarea cromozomilor

Fiecare **cromozom** reprezintă un **tur complet** al orașelor.  
Exemplu pentru $n = 5$ orașe: `[2, 3, 5, 1, 4]`

- Aceasta este o **permutare** a mulțimii ${1, 2, ..., n}$.
- Este important ca soluțiile să nu aibă orașe duplicate sau lipsă.


#### Funcția de fitness

Trebuie să minimizăm lungimea totală a turului. Pentru un tur $T = [t_1, t_2, ..., t_n]$, fitness-ul este:

$f(T) = \sum_{i=1}^{n-1} d(t_i, t_{i+1}) + d(t_n, t_1)$

> Fitness-ul poate fi inversul distanței pentru a transforma problema de **minimizare** într-una de **maximizare**:

$\text{fitness}(T) = \frac{1}{f(T)}$


#### Operatorii genetici

##### 1. Selecție

- Se folosește **selecție turneu** sau **ruletă** pentru a selecta părinți pe baza fitness-ului.
##### 2. Încrucișare (Crossover)

La TSP, crossover-ul trebuie să **respecte constrângerile**: nicio dublură, toți orașele prezente. Se folosesc metode speciale:

- **Order Crossover (OX)**:
    - Alege o secțiune din primul părinte și o copiază în copil.
    - Completează restul turului în ordinea în care apar orașele în al doilea părinte.

##### 3. Mutație

- **Swap Mutation**: se aleg două poziții și se inversează.
- **Scramble Mutation**: se alege o secțiune și se rearanjează aleator.
- **Inversion Mutation**: se inversează ordinea orașelor într-o secțiune.

#### Pseudocod

```text
Inițializează o populație de tururi (permutări ale orașelor)
Cât timp nu s-a atins criteriul de oprire:
    Evaluează fitness-ul fiecărui tur
    Selectează părinți
    Aplică crossover pentru a produce descendenți
    Aplică mutație descendenților
    Formează noua populație
Returnează cel mai scurt tur găsit
```



#### Exemplu simplificat

Orașe: $A, B, C, D$  
Coordonate:

- $A = (0, 0)$
- $B = (1, 0)$
- $C = (1, 1)$
- $D = (0, 1)$

Tur: `[A, B, C, D]`  
Distanța totală:

`AB + BC + CD + DA = 1 + 1 + 1 + 1 = 4`
Un alt tur: `[A, C, B, D]`  
Distanța:

$AC + CB + BD + DA = \sqrt{2} + 1 + \sqrt{2} + 1 \approx 5.83$

Primul tur este mai bun → fitness mai mare.


#### Avantaje și provocări

**Avantaje**:

- Se pot aplica la probleme unde soluția exactă este ineficientă (TSP are complexitate factorială).
- Nu necesită cunoștințe despre derivabilitate sau continuitate.

**Provocări**:

- Trebuie evitate soluții invalide (dubluri/lipsă de orașe).
- Algoritmul poate converge prematur la un tur suboptim.
- Performanța depinde mult de alegerea operatorilor genetici.
